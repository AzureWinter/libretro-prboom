diff --git a/src/p_setup.c b/src/p_setup.c
index 21db793..bd7aed2 100644
--- a/src/p_setup.c
+++ b/src/p_setup.c
@@ -650,6 +650,8 @@ static void P_LoadSectors (int lump)
       sector_t *ss = sectors + i;
       const mapsector_t *ms = (const mapsector_t *) data + i;
 
+      // [kb] for R_FixWiggle()
+		ss->cachedheight = 0;
       ss->iSectorID=i; // proff 04/05/2000: needed for OpenGL
       ss->floorheight = SHORT(ms->floorheight)<<FRACBITS;
       ss->ceilingheight = SHORT(ms->ceilingheight)<<FRACBITS;
diff --git a/src/r_defs.h b/src/r_defs.h
index 6f5ec80..7da92ad 100644
--- a/src/r_defs.h
+++ b/src/r_defs.h
@@ -86,6 +86,10 @@ typedef struct
 
 typedef struct
 {
+  // [kb] for R_FixWiggle()
+  int	cachedheight;
+  int	scaleindex;
+
   int iSectorID; // proff 04/05/2000: needed for OpenGL and used in debugmode by the HUD to draw sectornum
   boolean no_toptextures;
   boolean no_bottomtextures;
diff --git a/src/r_segs.c b/src/r_segs.c
index 284f323..1cd241d 100644
--- a/src/r_segs.c
+++ b/src/r_segs.c
@@ -90,6 +90,98 @@ static fixed_t  bottomfrac;
 static fixed_t  bottomstep;
 static int      *maskedtexturecol; // dropoff overflow
 
+//
+// R_FixWiggle()
+// Dynamic wall/texture rescaler, AKA "WiggleHack II"
+//  by Kurt "kb1" Baumgardner ("kb") and Andrey "Entryway" Budko ("e6y")
+//
+//  [kb] When the rendered view is positioned, such that the viewer is
+//   looking almost parallel down a wall, the result of the scale
+//   calculation in R_ScaleFromGlobalAngle becomes very large. And, the
+//   taller the wall, the larger that value becomes. If these large
+//   values were used as-is, subsequent calculations would overflow,
+//   causing full-screen HOM, and possible program crashes.
+//
+//  Therefore, vanilla Doom clamps this scale calculation, preventing it
+//   from becoming larger than 0x400000 (64*FRACUNIT). This number was
+//   chosen carefully, to allow reasonably-tight angles, with reasonably
+//   tall sectors to be rendered, within the limits of the fixed-point
+//   math system being used. When the scale gets clamped, Doom cannot
+//   properly render the wall, causing an undesirable wall-bending
+//   effect that I call "floor wiggle". Not a crash, but still ugly.
+//
+//  Modern source ports offer higher video resolutions, which worsens
+//   the issue. And, Doom is simply not adjusted for the taller walls
+//   found in many PWADs.
+//
+//  This code attempts to correct these issues, by dynamically
+//   adjusting the fixed-point math, and the maximum scale clamp,
+//   on a wall-by-wall basis. This has 2 effects:
+//
+//  1. Floor wiggle is greatly reduced and/or eliminated.
+//  2. Overflow is no longer possible, even in levels with maximum
+//     height sectors (65535 is the theoretical height, though Doom
+//     cannot handle sectors > 32767 units in height.
+//
+//  The code is not perfect across all situations. Some floor wiggle can
+//   still be seen, and some texture strips may be slightly misaligned in
+//   extreme cases. These effects cannot be corrected further, without
+//   increasing the precision of various renderer variables, and, 
+//   possibly, creating a noticable performance penalty.
+//   
+
+static int			max_rwscale = 64 * FRACUNIT;
+static int			heightbits = 12;
+static int			heightunit = (1 << 12);
+static int			invhgtbits = 4;
+ 
+static const struct
+{
+	int clamp;
+	int heightbits;
+}	
+	scale_values[8] = {
+		{2048 * FRACUNIT, 12}, {1024 * FRACUNIT, 12},
+		{1024 * FRACUNIT, 11}, { 512 * FRACUNIT, 11},
+		{ 512 * FRACUNIT, 10}, { 256 * FRACUNIT, 10},
+		{ 256 * FRACUNIT,  9}, { 128 * FRACUNIT,  9}
+	
+};
+
+void R_FixWiggle (sector_t *sector)
+{
+	static int	lastheight = 0;
+	int		height = (sector->ceilingheight - sector->floorheight) >> FRACBITS;
+
+	// disallow negative heights. using 1 forces cache initialization
+	if (height < 1)
+		height = 1;
+
+	// early out?
+	if (height != lastheight)
+	{
+		lastheight = height;
+
+		// initialize, or handle moving sector
+		if (height != sector->cachedheight)
+		{
+			sector->cachedheight = height;
+			sector->scaleindex = 0;
+			height >>= 7;
+
+			// calculate adjustment
+			while (height >>= 1)
+				sector->scaleindex++;
+		}
+
+		// fine-tune renderer for this wall
+		max_rwscale = scale_values[sector->scaleindex].clamp;
+		heightbits = scale_values[sector->scaleindex].heightbits;
+		heightunit = (1 << heightbits);
+		invhgtbits = FRACBITS - heightbits;
+	}
+}
+
 //
 // R_ScaleFromGlobalAngle
 // Returns the texture mapping scale
@@ -107,8 +199,23 @@ static fixed_t R_ScaleFromGlobalAngle(angle_t visangle)
    int     den = FixedMul(rw_distance, finesine[anglea>>ANGLETOFINESHIFT]);
    // proff 11/06/98: Changed for high-res
    fixed_t num = FixedMul(projectiony, finesine[angleb>>ANGLETOFINESHIFT]);
-   return den > num>>16 ? (num = FixedDiv(num, den)) > 64*FRACUNIT ?
-      64*FRACUNIT : num < 256 ? 256 : num : 64*FRACUNIT;
+   fixed_t scale;
+
+   if (den > (num >> 16))
+   {
+      scale = FixedDiv(num, den);
+
+      // [kb] When this evaluates True, the scale is clamped,
+		//  and there will be some wiggling.
+      if (scale > max_rwscale)
+         scale = max_rwscale;
+      else if (scale <  256)
+         scale = 256;
+   }
+   else
+      scale = max_rwscale;
+
+   return scale;
 }
 
 //
@@ -245,8 +352,6 @@ void R_RenderMaskedSegRange(drawseg_t *ds, int x1, int x2)
 // CALLED: CORE LOOPING ROUTINE.
 //
 
-#define HEIGHTBITS 12
-#define HEIGHTUNIT (1<<HEIGHTBITS)
 static int didsolidcol; /* True if at least one column was marked solid */
 
 static void R_RenderSegLoop (void)
@@ -263,8 +368,8 @@ static void R_RenderSegLoop (void)
    for ( ; rw_x < rw_stopx ; rw_x++)
    {
       /* mark floor / ceiling areas */
-      int yh = bottomfrac>>HEIGHTBITS;
-      int yl = (topfrac+HEIGHTUNIT-1)>>HEIGHTBITS;
+      int yh = bottomfrac>>heightbits;
+      int yl = (topfrac+heightunit-1)>>heightbits;
 
       // no space above wall?
       int bottom,top = ceilingclip[rw_x]+1;
@@ -288,7 +393,7 @@ static void R_RenderSegLoop (void)
          ceilingclip[rw_x] = bottom;
       }
 
-      //      yh = bottomfrac>>HEIGHTBITS;
+      //      yh = bottomfrac>>heightbits;
 
       bottom = floorclip[rw_x]-1;
       if (yh > bottom)
@@ -353,7 +458,7 @@ static void R_RenderSegLoop (void)
          if (toptexture)
          {
             // top wall
-            int mid = pixhigh>>HEIGHTBITS;
+            int mid = pixhigh>>heightbits;
             pixhigh += pixhighstep;
 
             if (mid >= floorclip[rw_x])
@@ -386,7 +491,7 @@ static void R_RenderSegLoop (void)
 
          if (bottomtexture)          // bottom wall
          {
-            int mid = (pixlow+HEIGHTUNIT-1)>>HEIGHTBITS;
+            int mid = (pixlow+heightunit-1)>>heightbits;
             pixlow += pixlowstep;
 
             // no space above wall?
@@ -530,6 +635,8 @@ void R_StoreWallRange(const int start, const int stop)
       }
    }  // killough: end of code to remove limits on openings
 
+   R_FixWiggle(frontsector);
+
    // calculate scale at both ends and step
 
    ds_p->scale1 = rw_scale =
@@ -731,28 +838,28 @@ void R_StoreWallRange(const int start, const int stop)
    }
 
    // calculate incremental stepping values for texture edges
-   worldtop >>= 4;
-   worldbottom >>= 4;
+   worldtop >>= invhgtbits;
+   worldbottom >>= invhgtbits;
 
    topstep = -FixedMul (rw_scalestep, worldtop);
-   topfrac = (centeryfrac>>4) - FixedMul (worldtop, rw_scale);
+   topfrac = (centeryfrac >> invhgtbits) - FixedMul (worldtop, rw_scale);
 
    bottomstep = -FixedMul (rw_scalestep,worldbottom);
-   bottomfrac = (centeryfrac>>4) - FixedMul (worldbottom, rw_scale);
+   bottomfrac = (centeryfrac >> invhgtbits) - FixedMul (worldbottom, rw_scale);
 
    if (backsector)
    {
-      worldhigh >>= 4;
-      worldlow >>= 4;
+      worldhigh >>= invhgtbits;
+      worldlow >>= invhgtbits;
 
       if (worldhigh < worldtop)
       {
-         pixhigh = (centeryfrac>>4) - FixedMul (worldhigh, rw_scale);
+         pixhigh = (centeryfrac >> invhgtbits) - FixedMul (worldhigh, rw_scale);
          pixhighstep = -FixedMul (rw_scalestep,worldhigh);
       }
       if (worldlow > worldbottom)
       {
-         pixlow = (centeryfrac>>4) - FixedMul (worldlow, rw_scale);
+         pixlow = (centeryfrac >> invhgtbits) - FixedMul (worldlow, rw_scale);
          pixlowstep = -FixedMul (rw_scalestep,worldlow);
       }
    }
